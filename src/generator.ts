import { OpenAPIV3 } from "openapi-types";
import { OperationInfo } from "./index"; // Import shared type
import {
  toTsIdentifier,
  toPascalCase,
  getPathBasedBaseName,
  createTopLevelBanner,
  createOperationGroupBanner,
} from "./helpers/generator-helpers";
import { PackageConfig, ResolvedPackageConfig, defaultConfig } from "./config";
// Corrected path: ./ instead of ../
// Import the new helper function
import { _generateFunctionFactory, _generateOperationTypes, _generateHookFactory } from "./helpers/generator-parts";

export async function generateFilesForTag(
  tagName: string,
  operations: OperationInfo[],
  spec: OpenAPIV3.Document,
  reactQueryEnabled: boolean,
  packageConfig: ResolvedPackageConfig
): Promise<{
  typesContent: string;
  functionsContent: string;
  hooksContent: string;
  functionFactoryNames: string[];
  hookFactoryNames: string[];
  hasGeneratedTypes: boolean;
}> {
  const standardFileComment = `/* eslint-disable */\n/**\n * This file was automatically generated by sg-schema-sync.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,\n * and run sg-schema-sync to regenerate this file.\n */`;

  // Create top-level banner for types file
  const typeTopBanner = createTopLevelBanner("types");
  let typesContent = `${typeTopBanner}\n\n${standardFileComment}\n`; // Ensures standard comment is present

  // Create top-level banner for functions file
  const functionTopBanner = createTopLevelBanner("functions");
  let functionsFilePreamble: string[] = [`${functionTopBanner}\n\n${standardFileComment}\n`];
  let functionDefinitions: string[] = [];

  const tagImportName = toTsIdentifier(tagName) + "Types";
  const sanitizedTagName = tagName.toLowerCase().replace(/\s+|\//g, "-");

  let anyFunctionNeedsTypesImport = false;
  let anyHookNeedsTypesImport = false;

  const generatedTypeNames = new Set<string>();
  const functionFactoryNames: string[] = [];
  const hookFactoryNames: string[] = [];

  if (packageConfig.verbose) console.log(`  Processing ${operations.length} operations for tag: ${tagName}`);

  let hooksContentParts: string[] = [];
  let hooksGenerated = false;
  let hasGeneratedQueryHooks = false;
  let hasGeneratedMutationHooks = false;

  for (const opInfo of operations) {
    const { operation, path, method } = opInfo;
    const operationId = operation.operationId;
    let processedPath = path;
    if (packageConfig.stripPathPrefix && processedPath.startsWith(packageConfig.stripPathPrefix)) {
      processedPath = processedPath.substring(packageConfig.stripPathPrefix.length);
      if (processedPath && !processedPath.startsWith("/")) {
        processedPath = "/" + processedPath;
      }
    }

    const baseNameForTypes = operationId ? toPascalCase(operationId) : getPathBasedBaseName(path);
    const methodPascal = toPascalCase(method);
    const endpointBaseName = getPathBasedBaseName(processedPath);

    const functionName = (packageConfig.generateFunctionNames ?? defaultConfig.generateFunctionNames!)
      .replace("{method}", methodPascal)
      .replace("{Endpoint}", endpointBaseName);

    const typeBaseNameForOperation = (packageConfig.generateTypesNames ?? defaultConfig.generateTypesNames!)
      .replace("{Method}", methodPascal)
      .replace("{Endpoint}", endpointBaseName);

    const hookBaseName = (packageConfig.generateHooksNames ?? defaultConfig.generateHooksNames!)
      .replace("{Method}", methodPascal)
      .replace("{Endpoint}", endpointBaseName);

    const summary = operation.summary || "No Description Provided";
    const operationGroupBanner = createOperationGroupBanner(operation.summary, method, processedPath);

    typesContent += `\n\n${operationGroupBanner}\n`;

    const {
      typesString: operationTypesString,
      requestBodyTypeName: actualRequestBodyTypeName,
      parametersTypeName: actualParametersTypeName,
      primaryResponseTypeName,
      requestBodyFailed,
      parametersTypeFailed,
      responseTypeFailed,
      primaryResponseTypeGenerated,
    } = await _generateOperationTypes(
      opInfo,
      typeBaseNameForOperation,
      tagName,
      generatedTypeNames,
      spec,
      packageConfig
    );
    typesContent += operationTypesString;

    // Check if this operation necessitates importing from ./types
    // A prefixed type import is needed if any default type will actually use the prefix.
    const usesPrefixedResponseType =
      primaryResponseTypeName && primaryResponseTypeName !== "void" && primaryResponseTypeGenerated;
    const usesPrefixedRequestBodyType = actualRequestBodyTypeName && !requestBodyFailed;
    const usesPrefixedParametersType = actualParametersTypeName && !parametersTypeFailed;

    const needsTypesForThisOperation =
      usesPrefixedResponseType || usesPrefixedRequestBodyType || usesPrefixedParametersType;

    if (needsTypesForThisOperation) {
      anyFunctionNeedsTypesImport = true;
      if (reactQueryEnabled && packageConfig.generateHooks) {
        anyHookNeedsTypesImport = true;
      }
    }

    const authRequire = !!(operation.security && operation.security.length > 0);
    const pathParams =
      (operation.parameters?.filter(
        (p) => (p as OpenAPIV3.ParameterObject).in === "path"
      ) as OpenAPIV3.ParameterObject[]) || [];

    const currentFunctionFactoryString = _generateFunctionFactory(
      opInfo,
      functionName,
      summary,
      operationGroupBanner,
      tagImportName,
      processedPath,
      authRequire,
      actualRequestBodyTypeName,
      actualParametersTypeName,
      primaryResponseTypeName,
      requestBodyFailed,
      parametersTypeFailed,
      responseTypeFailed,
      primaryResponseTypeGenerated,
      packageConfig
    );
    if (currentFunctionFactoryString && currentFunctionFactoryString.trim() !== "") {
      functionDefinitions.push(currentFunctionFactoryString);
    }
    functionFactoryNames.push(functionName);

    if (reactQueryEnabled && packageConfig.generateHooks) {
      hooksGenerated = true;
      const hookFactoryName = `create${hookBaseName}Hook`;
      const currentHookFactoryString = _generateHookFactory(
        opInfo,
        hookFactoryName,
        functionName,
        summary,
        operationGroupBanner,
        tagImportName,
        sanitizedTagName,
        endpointBaseName,
        processedPath,
        actualRequestBodyTypeName,
        actualParametersTypeName,
        primaryResponseTypeName,
        primaryResponseTypeGenerated,
        pathParams,
        packageConfig
      );
      if (currentHookFactoryString && currentHookFactoryString.trim() !== "") {
        hooksContentParts.push(currentHookFactoryString);
        hookFactoryNames.push(hookFactoryName);
        if (opInfo.method.toLowerCase() === "get") {
          hasGeneratedQueryHooks = true;
        } else {
          hasGeneratedMutationHooks = true;
        }
      } else {
        if (packageConfig.verbose) {
          console.log(`    [${tagName}] _generateHookFactory returned empty for ${hookFactoryName}, skipping.`);
        }
      }
    }
  }

  let importsAddedToFunctionsPreamble = false;
  const requiredBaseRequesterTypesForFunctions: string[] = [];
  if (functionFactoryNames.length > 0) {
    requiredBaseRequesterTypesForFunctions.push("SGSyncRequester");
    requiredBaseRequesterTypesForFunctions.push("SGSyncRequesterOptions");
  }

  if (requiredBaseRequesterTypesForFunctions.length > 0) {
    functionsFilePreamble.push(`// Imports for the requester mechanism\n`);
    functionsFilePreamble.push(
      `import { ${requiredBaseRequesterTypesForFunctions.join(", ")} } from 'sg-schema-sync/requester-types';\n`
    );
    importsAddedToFunctionsPreamble = true;
  }

  if (anyFunctionNeedsTypesImport) {
    functionsFilePreamble.push(`import * as ${tagImportName} from './types';\n`);
    importsAddedToFunctionsPreamble = true;
  }

  if (importsAddedToFunctionsPreamble) {
    functionsFilePreamble.push(`\n`);
  }

  const functionsContent = [...functionsFilePreamble, ...functionDefinitions].join("\n");

  let hooksContent = "";
  if (reactQueryEnabled && hooksGenerated) {
    const hookTopBanner = createTopLevelBanner("hooks");
    let finalHooksImports = `// Imports for the requester mechanism and TanStack Query\n`;

    if (hookFactoryNames.length > 0) {
      finalHooksImports += `import { SGSyncRequester } from 'sg-schema-sync/requester-types';\n`;
    }

    if (anyHookNeedsTypesImport) {
      finalHooksImports += `import * as ${tagImportName} from './types';\n`;
    }

    const tanstackImports: string[] = [];
    if (hasGeneratedQueryHooks) {
      tanstackImports.push("QueryFunctionContext", "useQuery", "UseQueryOptions");
    }
    if (hasGeneratedMutationHooks) {
      tanstackImports.push("useMutation", "UseMutationOptions");
    }
    if (tanstackImports.length > 0) {
      tanstackImports.sort();
      finalHooksImports += `import {\n  ${tanstackImports.join(",\n  ")}\n} from '@tanstack/react-query';\n`;
    }

    if (functionFactoryNames.length > 0) {
      let factoryImportStatements = "  " + functionFactoryNames.join(",\n  ");
      finalHooksImports += `import {\n${factoryImportStatements}\n} from './functions';\n`;
    }
    finalHooksImports += `\n`;

    hooksContent = `${hookTopBanner}\n\n${standardFileComment}\n\n${finalHooksImports}${hooksContentParts.join("")}`;
  } else if (reactQueryEnabled && !hooksGenerated) {
    const hookTopBanner = createTopLevelBanner("hooks");
    hooksContent = `${hookTopBanner}\n\n${standardFileComment}\n\n// React Query is enabled, but no hooks were generated for this tag.\n`;
    if (packageConfig.verbose)
      console.log(`  [RQ Summary] React Query enabled, but no hook factories were generated for tag: ${tagName}.`);
  }

  return {
    typesContent,
    functionsContent,
    hooksContent,
    functionFactoryNames,
    hookFactoryNames,
    hasGeneratedTypes: generatedTypeNames.size > 0, // This remains the indicator for whether any types were generated *at all*
  };
}
